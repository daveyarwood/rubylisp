; TODO:
; and, or
; implement macros
; defn
; comment
; ->, ->>
; private vars/fns
; if-not, when, when-not, if-let, when-let
; cond
; case
; destructuring

(ns rubylisp.core)

;; MATH & LOGIC

(def +
  (fn + [x y & more]
    (let [xy (.+ x y)]
      (if more
        (apply + xy more)
        xy))))

(def -
  (fn - [x y & more]
    (let [xy (.- x y)]
      (if more
        (apply - xy more)
        xy))))

(def inc
  (fn inc [x]
    (+ x 1)))

(def dec
  (fn dec [x]
    (- x 1)))

(def *
  (fn * [x y & more]
    (let [xy (.* x y)]
      (if more
        (apply * xy more)
        xy))))

(def /
  (fn / [x y & more]
    (let [xy (./ x y)]
      (if more
        (apply / xy more)
        xy))))

(def <
  (fn < [x y & more]
    (let [xy (.< x y)]
      (if more
        (apply < xy more)
        xy))))

(def <=
  (fn <= [x y & more]
    (let [xy (.<= x y)]
      (if more
        (apply <= xy more)
        xy))))

(def =
  (fn = [x y & more]
    (let [xy (.== x y)]
      (if more
        (apply = xy more)
        xy))))

(def not=
  (fn not= [x y & more]
    (let [xy (.!= x y)]
      (if more
        (apply not= xy more)
        xy))))

(def boolean
  (fn boolean [x]
    (if x true false)))

(def not
  (fn not [x]
    (if x false true)))

(def >
  (fn > [x y & more]
    (let [xy (.> x y)]
      (if more
        (apply > xy more)
        xy))))

(def >=
  (fn >= [x y & more]
    (let [xy (.>= x y)]
      (if more
        (apply >= xy more)
        xy))))

(def pos?
  (fn pos? [x]
    (> x 0)))

(def neg?
  (fn neg? [x]
    (< x 0)))

(def zero?
  (fn zero? [x]
    (= 0 x)))

;; LISTS & OTHER COLLECTIONS

(def nil?
  (fn nil? [x]
    (= nil x)))

(def string?
  (fn string? [x]
    (.is_a? x Kernel::String)))

;; TODO: implement & use cond
(def count
  (fn count [x]
    (if (nil? x)
      0
      (if (string? x)
        (.count (seq x))
        (.count x)))))

(def empty?
  (fn empty? [coll]
    (if (nil? coll)
      true
      (.empty? coll))))

(def list
  (fn list [& args]
    (.to_list (if (nil? args)
                []
                args))))

(def list?
  (fn list? [x]
    (.is_a? x Hamster::List)))

(def vector
  (fn vector [& args]
    (Hamster::Vector::new args)))

(def vector?
  (fn vector? [x]
    (.is_a? x Hamster::Vector)))

;; TODO: implement `or` and use it here
(def sequential?
  (fn sequential? [x]
    (if (list? x)
      true
      (if (vector? x)
        true
        (if (.is_a? x Kernel::Array)
          true
          false)
        false)
      false)))

(def vec
  (fn vec [coll]
    (Hamster::Vector::new coll)))

(def hash-map
	(fn hash-map [& args]
    (Hamster::Hash::new (.to_h (.each_slice args 2)))))

(def map?
  (fn map? [x]
    (.is_a? x Hamster::Hash)))

(def seq
  (fn seq [x]
    (if (not (empty? x))
      (if (string? x)
        (.to_list (.chars x))
        (.to_list x)))))

(def cons
  (fn cons [x y]
    (let [lst (if (nil? y) () (.to_list y))]
      (.cons lst x))))

;; TODO: define cond and use it here
(def concat
  (fn concat [& colls]
    (if (nil? colls)
      ()
      (if (= 1 (count colls))
        (first colls)
        (apply + (first colls) (map seq (rest colls)))))))

(def nth
  ;; TODO: multiple arity fn
  (fn nth [coll index & more]
    (if more
      (let [not-found (first more)]
        (if (>= index (count coll))
          not-found
          (.at coll index)))
      (if (>= index (count coll))
        (Kernel::raise Kernel::IndexError)
        (.at coll index)))))

(def first
  (fn first [coll]
    (if (not (nil? coll))
      (.first coll))))

(def second
  (fn second [coll]
    (nth coll 1)))

(def last
  (fn last [coll]
    (.last coll)))

(def rest
  (fn rest [coll]
    (let [lst (if (nil? coll) () (.to_list coll))]
      (.tail lst))))

(def take
  (fn take [n coll]
    (.to_list (.take coll n))))

;; TODO: use Hamster::List::map instead for its laziness
;; (prerequisite: block syntax)
;; TODO: support mapping over multiple collections
(def map
  (fn map [f coll]
    (if (empty? coll)
      ()
      (cons (f (first coll)) (map f (rest coll))))))

(def reverse
  (fn reverse [coll]
    (if (empty? coll)
      coll
      (+ [(last coll)]
         (reverse (.slice coll 0 (dec (count coll))))))))

;; TODO: implement as multiple arity fn
;; TODO: zero-arity that produces a lazy list, i.e. Hamster::iterate(0,
;; &:next).take(5)
;; (requires some kind of block syntax)
(def range
  (fn range [& args]
    (if (= 1 (count args))
      (apply range 0 args)
      (apply Hamster::interval args))))

;; TODO: implement as multiple arity fn
(def repeat
  (fn repeat [& args]
    (if (= 1 (count args))
      (apply Hamster::repeat args)
      (apply Hamster::replicate args))))

;; STRINGS & KEYWORDS

(def str
  (fn str [& args]
    (.join (map .to_s args))))

(def name
  (fn name [x]
    (if (string? x)
      x
      (.name x))))

(def read-string
  (fn read-string [s]
    (first (RubyLisp::Reader::read_str s))))

;; problem: this is defined in rubylisp.core, so code is evaluated there
(def load-string
  (fn load-string [s]
    (eval (RubyLisp::Reader::read_str s))))

;; I/O

(def pr-str
  (fn pr-str [& args]
    (if (zero? (count args))
      ""
      (apply RubyLisp::Printer::pr_str args))))

(def prn
  (fn prn [& args]
    (Kernel::puts (apply pr-str args))
    nil))

(def print
  (fn print [& args]
    (Kernel::print (.join (map str args) " "))
    nil))

(def println
  (fn print [& args]
    (Kernel::puts (.join (map str args) " "))
    nil))

(def slurp
  (fn slurp [filename]
    (File::read filename)))

(def load-file
  (fn load-file [filename]
    (load-string (slurp filename))))

;; RUBY INTEROP

(def =@
  (fn =@ [obj kw value]
    (.instance_variable_set obj (.to_sym (+ "@" (name kw))) value)))

(def class
  (fn class [x]
    (.class x)))

;; CONCURRENCY

(def deref
  (fn deref [x]
    (.deref x)))

(def atom
  (fn atom [value]
    (Concurrent::Atom::new value)))

(def atom?
  (fn atom? [value]
    (.is_a? value Concurrent::Atom)))

(def swap!
  (fn swap! [a f & args]
    (call-with-block .swap a (if (nil? args) [] args) f)))

(def reset!
  (fn reset! [a new-value]
    (.reset a new-value)))
